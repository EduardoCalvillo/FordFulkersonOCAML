open Graph
open FFulk
let () =

  if Array.length Sys.argv <> 5 then
    begin
      Printf.printf "\nUsage: %s infile source sink outfile\n\n%!" Sys.argv.(0) ;
      exit 0
    end ;

  let infile = Sys.argv.(1)
  and outfile = Sys.argv.(4)
  
  (* These command-line arguments are not used for the moment. *)
  and _source = Sys.argv.(2)
  and _sink = Sys.argv.(3)
  in

  (* Open file *)
  (*let graph = Gfile.from_file infile in *)
  let graph_flo =Gfile.from_file infile in 
 (* let intgraph = Graph.map graph int_of_string in*)
  let intgraph_flo = Graph.map graph_flo int_of_string in

  let chemin = FFulk.parcour intgraph_flo _source _sink in 
  (* Rewrite the graph that has been read. *)
 (* let intgraph2 = Graph.map intgraph string_of_int in (*on reconvertit les labels en string pour pouvoir les écrire*)*)
  
  let delta= FFulk.find_delta intgraph_flo chemin in

 
  let graph_flo = Graph.map intgraph_flo string_of_int in

  let ()=Gfile.export outfile graph_flo in
 (* let delta (*min (min flow arc normaux (on l'a déjà parcqu'on décrémente au fur et à mesure, min flow arc inverse (on le calcul grace au graph initial que l'on aura sauvegardé: C=cout, C(graph init)-C(graph))
Une fois qu'on a le delta on dcrémente notre graphe (on s'en fou des arcs inverses (calculable grace aux graph initial)

-> on continue
-> recherche d'un nouveau parcours (COMMENT SELECTIONNER NOTRE Parcours) avec le flot dispo?*)
*)

let fire chemin delta intgraph_flo= 

Printf.printf "Le chemin choisis est: ";
List.iter (fun x->Printf.printf "%s " x) chemin;
Printf.printf "\nLe delta est: %d\n" delta;

let intgraph_flo_new=FFulk.update intgraph_flo delta chemin in

let chemin_new= FFulk.parcour intgraph_flo_new _source _sink in
let delta_new= FFulk.find_delta intgraph_flo_new chemin_new in
Printf.printf "Le chemin choisis est: ";
List.iter (fun x->Printf.printf "%s " x) chemin_new;
Printf.printf "\nLe delta est: %d\n" delta_new;

let intgraph_flo_new2=FFulk.update intgraph_flo_new delta_new chemin_new in

let chemin_new2= FFulk.parcour intgraph_flo_new2 _source _sink in
let delta_new2= FFulk.find_delta intgraph_flo_new2 chemin_new2 in
Printf.printf "Le chemin choisis est: ";
List.iter (fun x->Printf.printf "%s " x) chemin_new2;
Printf.printf "\nLe delta est: %d\n" delta_new2;

let intgraph_flo_new3=FFulk.update intgraph_flo_new2 delta_new2 chemin_new2 in


Gfile.export outfile (Graph.map intgraph_flo_new3 string_of_int);
Printf.printf "FINI ";


in



fire chemin delta intgraph_flo;



(*Dans FIRE creer une boucle pour itérer et modifier la function parcour pour qu'elle puisse retourner en arrière quand il y a cul de sac

*)
